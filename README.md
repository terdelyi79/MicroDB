# MicroDB - A Durable In-Memory Relational Database Library Optimized for Performance and Productivity

This is the **Proof of Concept version** of a Durable In-Memory Relational Database Library called MicroDB. It has similar advantages as Amazon MemoryDB, but optimized not only for performance, but for productivity as well.

MicroDB has the following benefits:

 * **Crazy performance**: Database tables and transaction logs are stored in the memory. Disk usage is minimal,.
 * **Serialized ACID Transactions**: The durable, atomic transactions are serialized, therefore isolation level specific issues and deadlocks are avoided.
 * **Tables are based on Rust structs**: The whole database is strongly typed to avoid runtime errors. (without any OR mapping!)
 * **Flexible selects from tables by Rust iterators**: In the same way as from any other collections in Rust.
 * **Strongly typed database functions and stored procedures in Rust**: Whole database functionality can be easily unit-tested.
 * **Custom field types with full transaction support**: Any serializable types can be used for fields. Transactions are handled on them without any extra implementation.
 * **Zero deployment**: Database service built by the library can be deployed as a simple executable without any dependency.

## How MicroDB works?

MicroDB is based on the CQRS (Command and Query Responsibility Segregation) and Event Sourcing patterns. A query is a read only operation on the database returning a result set (like SQL SELECT statements in relational databases), a command changes the database but does not return any result. While multiple queries can run at the same time (reading database data from the memory in parallel), a command locks the database. Queries are executed immediately, but commands are asynchronous. When a command is received, their parameters are serialized and stored on the disk, then command is executed in the memory, while transaction log is written to the memory as well. On soft errors it is used to roll back the transaction. On hard errors however, the transactions are executed in the same order again to build up the database. After lots of transactions however, this would be slow (and disk space usage would be huge as well). This issue will be handled by snapshots, what is not implemented in the proof of concept version. A snapshot is the state of all tables written to the disk. On hard errors or restarts, the latest snapshot can be loaded, and only transactions that arrived after the snapshot generation must be executed. Snapshots will be generated by a serverless function, what reads the last snapshot, executes transactions arrived after that, then saves the new snapshot. Serialized commands can be either deleted or archived after that.

## The MicroDB sample project

Sample project contains a very basic database service for airlines. It can store airports, flights, and reservations. The executable measures the performance of a basic command, but unit tests in airline_service.rs demonstrate some interesting features:

 * reservation_test: Demonstrates automatic transaction handling. When a command tries to reserve two seats on a flight, but only one is avaiable, then first one is rolled back.
 * flight_schedule_change_test: Shows that automatic transaction handling works with custom field types as well. HoursAndMinutes struct is used to represent flight departure and arrival times. If its fields (hours, minutes) are changed, then they are automatically rolled back on transaction failure.
 * find_fastest_route: Demonstrates how easy is to write a complex query in rust instead of using SQL extensions like PLSQL or Transact SQL. The find_fastest_route returns the fastest route on a day from a specific airport to another one.



